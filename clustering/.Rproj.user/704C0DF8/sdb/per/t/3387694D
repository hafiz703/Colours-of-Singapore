{
    "collab_server" : "",
    "contents" : "library(data.table)\nlibrary(rgl)\n#colors <- read.csv(\"average.csv\", stringsAsFactors = F) \ncolors <- read.csv(\"Flickr/Mode/averageMode.csv\", stringsAsFactors = F) \n#colors <- read.csv(\"Flickr/noGrey/averageNoGrey.csv\", stringsAsFactors = F) \n#colors <- read.csv(\"Flickr/100x100/average-max-100x100.csv\", stringsAsFactors = F) \n#colors <- read.csv(\"colors.csv\", stringsAsFactors = F)\n\ndtColors <- setDT(colors)\n\ndtColors <- dtColors[R != 'NA',,]\ndtColors <- dtColors[R != '0' & G != '0' & B != '0',,]\n\n## tabulate the avg R,G and B for eachh cluster\n#Colors.clusterAvg <- dtColors[,list(R.avg = mean(R),G.avg = mean(G),B.avg = mean(B)),by=cluster,]\n#Colors.clusterAvg <- Colors.clusterAvg[,hexColor := rgb(Colors.clusterAvg[,R.avg], Colors.clusterAvg[,G.avg], Colors.clusterAvg[,B.avg], maxColorValue=255),]\n\n#function to get mode\ngetmode <- function(v) {\n  uniqv <- unique(v)\n  uniqv[which.max(tabulate(match(v, uniqv)))]\n}\n\n# function to get mode\ngetCluster <- function(hue) {\n  if (hue > 11/12.0 || hue <= 1/12.0) {\n    return('Red')\n  } else if (hue > 1/12.0 && hue <= 3/12.0) {\n    return('Yellow')\n  } else if (hue > 3/12.0 && hue <= 5/12.0) {\n    return('Green')\n  } else if (hue > 5/12.0 && hue <= 7/12.0) {\n    return('Cyan')\n  } else if (hue > 7/12.0 && hue <= 9/12.0) {\n    return('Blue')\n  } else {\n    return('Magenta')\n  }\n}\n\n# vectorize getCluster function so that it can process vector correctly, otherwise use many nested ifelse()\ngetClusterVector <- Vectorize(getCluster)\n\n#clusterColors <- dtColors[ ,list(cluster = getmode(cluster)),by=.(Lat,Lon)]\n#clusterColors <- merge(clusterColors, Colors.clusterAvg, by = \"cluster\")\n#clusterColors <- clusterColors[,list(cluster,Lat,Lon,hexColor),]\n\n#fwrite(clusterColors, \"hexWith100x100Clusters.csv\")\n\n#fwrite(dtColors, \"colorsMode.csv\")\n#fwrite(Colors.clusterAvg, \"clusterMode.csv\")\n#fwrite(avgColorPerHex, \"avgColorPerHex.csv\")\n\n# convert RGB to HSV and transpose matrix to get H,S and V as columns \nhsvColor <- t(rgb2hsv(dtColors[,R], dtColors[,G], dtColors[,B], maxColorValue = 255))\nhsvColor <- data.table(hsvColor)\nhsvColor <- hsvColor[,cluster := getClusterVector(h),]\nhsvColor <- hsvColor[s < 0.05 & v > 0.9,cluster := 'White',]\n# hsvColor <- hsvColor[s < 0.01 & v > 0.9,cluster := 'White',]\nhsvColor <- hsvColor[v < 0.1,cluster := 'Black',]\nhsvColor <- hsvColor[s < 0.1 & cluster != \"White\" & cluster != \"Black\",cluster := 'Gray',]\n\n#Sequence to write id col for both data table\nhsvColor$id <- seq.int(nrow(hsvColor))\ndtColors$id <- seq.int(nrow(dtColors))\n\n#merge data table\nhsvColor2 <- merge(hsvColor,dtColors,by = \"id\")\n\n#Remove Black, White and Gray\nhsvColor2 <- hsvColor2[cluster != \"White\",,]\nhsvColor2 <- hsvColor2[cluster != \"Black\",,]\nhsvColor2 <- hsvColor2[cluster != \"Gray\",,]\n\n## finding average color of cluster as representative\ncolorClusters <- hsvColor2[,list(R.avg = mean(R),G.avg = mean(G),B.avg = mean(B)),by=cluster,]\ncolorClusters <- colorClusters[,hexColor := rgb(colorClusters[,R.avg], colorClusters[,G.avg], colorClusters[,B.avg], maxColorValue=255),]\ncolorClusters <- colorClusters[,list(cluster,hexColor),]\n\n# customClusterRep <- colorClusters\n# customClusterRep[cluster == \"Red\",hexColor = \"\",]\n\nhsvColor2 <- merge(colorClusters,hsvColor2,by = \"cluster\")\n\nclusterColors <- hsvColor2[ ,list(cluster = getmode(cluster)),by=.(Lat,Lon)]\nclusterColors <- merge(clusterColors, colorClusters, by = \"cluster\")\n\nfwrite(clusterColors, \"colorsHSV.csv\")\n\n# For testing number of Cyan pics in each Lat,Lon\ntestCyan <- hsvColor2[cluster == \"Cyan\",.N,by = .(Lat,Lon)]\nsetnames(testCyan,\"N\",\"N.Cyan\")\ntestBlue <- hsvColor2[cluster == \"Blue\",.N,by = .(Lat,Lon)]\nsetnames(testBlue,\"N\",\"N.Blue\")\ntestYellow <- hsvColor2[cluster == \"Yellow\",.N,by = .(Lat,Lon)]\nsetnames(testYellow,\"N\",\"N.Yellow\")\ntestRed <- hsvColor2[cluster == \"Red\",.N,by = .(Lat,Lon)]\nsetnames(testRed,\"N\",\"N.Red\")\ntestGreen <- hsvColor2[cluster == \"Green\",.N,by = .(Lat,Lon)]\nsetnames(testGreen,\"N\",\"N.Green\")\ntestMagenta <- hsvColor2[cluster == \"Magenta\",.N,by = .(Lat,Lon)]\nsetnames(testMagenta,\"N\",\"N.Magenta\")\n#comparing the colours\nmergeTest <- merge(testBlue,testCyan,all = TRUE)\nmergeTest <- merge(mergeTest,testYellow,all = TRUE)\nmergeTest <- merge(mergeTest,testRed,all = TRUE)\nmergeTest <- merge(mergeTest,testGreen,all = TRUE)\nmergeTest <- merge(mergeTest,testMagenta,all = TRUE)\n\nmergeTest[is.na(mergeTest)] <- 0\n\nmergeTest <- mergeTest[,N.Total := N.Blue + N.Cyan + N.Yellow + N.Red + N.Green + N.Magenta,]\npercentMergeTest <- mergeTest[,N.Blue := round(N.Blue / N.Total,3),]\npercentMergeTest <- percentMergeTest[,N.Cyan := round(N.Cyan / N.Total,3),]\npercentMergeTest <- percentMergeTest[,N.Yellow := round(N.Yellow / N.Total,3),]\npercentMergeTest <- percentMergeTest[,N.Red := round(N.Red / N.Total,3),]\npercentMergeTest <- percentMergeTest[,N.Green := round(N.Green / N.Total,3),]\npercentMergeTest <- percentMergeTest[,N.Magenta := round(N.Magenta / N.Total,3),]\n\ntest <- percentMergeTest[N.Total >= 30,,]\n\nfwrite(mergeTest, \"ColorFreqForEachHex.csv\")\nfwrite(percentMergeTest, \"ColorPercentageForEachHex.csv\")\n\nlibrary(plotly)\nlibrary(dplyr)\n\np <- plot_ly(data = dtColors,x = ~R, y = ~G, z = ~B, type = \"scatter3d\", mode = \"markers\", color = ~cluster, text = ~paste(\"R: \", R, '<br>G:', G, '<br>B:', B), hoverinfo = \"text\") %>%      layout(title = \"3D Scatter plot of mode colors of hex of Singapore using Flickr photos\",            scene = list(xaxis = list(title = \"Red\",range = c(0,255)),yaxis = list(title = \"Green\",range = c(0,255)),zaxis = list(title = \"Blue\",range = c(0,255))))\np",
    "created" : 1491815464016.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1263695308",
    "id" : "3387694D",
    "lastKnownWriteTime" : 1492938589,
    "last_content_update" : 1492938589416,
    "path" : "C:/Users/Junsheng Lin/Dropbox/Sutd/Hass/Making Maps/Maps project/clustering/customHSVCluster.R",
    "project_path" : "customHSVCluster.R",
    "properties" : {
        "docOutlineVisible" : "0",
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}